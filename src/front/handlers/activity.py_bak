 # -*- coding: utf-8 -*-

import random
import time
import zlib
import uuid
import datetime
from twisted.internet import defer
from cyclone import escape, web
from front import storage
from front import utils
from front.utils import E
from front import D
 # from front.handlers.base import BaseHandler
from front.wiapi import *
from front.handlers.base import ApiHandler, ApiJSONEncoder

@handler
class GetHandler(ApiHandler):

    @storage.databaseSafe
    @defer.inlineCallbacks
    @utils.signed
    @api('Activity get', '/activity/get/', [
        Param('channel', False, str, 'putaogame', 'putaogame', 'channel'),
        Param('_sign', True, str, '4GRwMApTJ3VpZCcKcDEKUycxMScKcDIKcyK', '4GRwMApTJ3VpZCcKcDEKUycxMScKcDIKcyK', '_sign'),
        ], filters=[ps_filter], description="Activity get")
    def post(self):
        try:
            channel = self.get_argument("channel", "putaogame")  
        except Exception:
            raise web.HTTPError(400, "Argument error")
        uid = self.uid
        user = yield self.get_user(uid)
        channels = yield self.sql.runQuery("SELECT id FROM core_channel WHERE slug=%s LIMIT 1", (channel, ))
        if channels:
            channel_id, = channels[0]
        else:
            raise web.HTTPError(404)

        activity = {}
        res = yield self.sql.runQuery("SELECT a.aid, a.name, a.gold, a.rock, a.feat, a.hp, a.prods, a.nums, a.total, a.type, a.created_at,\
         a.ended_at FROM core_activity AS a, core_activity_channels AS b WHERE channel_id=%s AND a.id=b.activity_id", (channel_id, ))
        if res:
            for r in res:
                aid, name, gold, rock, feat, hp, prods, nums, total, atype, created_at, ended_at = r
                prods = dict(zip(prods.split(','), [int(n) for n in nums.split(',')]))
                created_at = int(time.mktime(created_at.timetuple()))
                ended_at = int(time.mktime(ended_at.timetuple()))
                now = int(time.mktime(datetime.datetime.now().timetuple()))
                if int(total) <= int(user['vrock']) and now >= created_at and now <= ended_at:
                    if aid not in user['activities']:
                        user['activities'][aid] = 0
                    else:
                        if user['activities'][aid] == -1:
                            user['activities'][aid] = 0
                else:
                    user['activities'][aid] = -1

                activity[aid] = dict(name=r[1], gold=r[2], rock=r[3], feat=r[4], hp=r[5], prods=prods, created_at=created_at,\
                 ended_at=ended_at, total=total, type=atype, status=user['activities'][aid])

        cuser = dict(activities=user['activities'])
        yield self.set_user(uid, **cuser)
        ret = dict(out=dict(activity=activity), timestamp=int(time.time()))
        reb = zlib.compress(escape.json_encode(ret))
        self.write(ret)

@handler
class SetHandler(ApiHandler):

    @storage.databaseSafe
    @defer.inlineCallbacks
    @utils.signed
    @api('Activity set', '/activity/set/', [
        Param('channel', False, str, 'putaogame', 'putaogame', 'channel'),
        Param('aid', True, str, '80001', '80001', 'aid'),
        Param('_sign', True, str, '4GRwMApTJ3VpZCcKcDEKUycxMScKcDIKcyK', '4GRwMApTJ3VpZCcKcDEKUycxMScKcDIKcyK', '_sign'),
        ], filters=[ps_filter], description="Activity set")
    def post(self):

        uu = self.get_argument("uu", None)
        if uu:
            uu = "%s:%s:%s" % (self.request.remote_ip, self.request.path, uu)
            ret = yield self.get_uu(uu)
            if ret:
                self.write(ret)
                return
        try:
            aid = self.get_argument("aid")
            channel = self.get_argument("channel", "putaogame")  
        except Exception:
            raise web.HTTPError(400, "Argument error")

        channels = yield self.sql.runQuery("SELECT id FROM core_channel WHERE slug=%s LIMIT 1", (channel, ))
        if channels:
            channel_id, = channels[0]
        else:
            raise web.HTTPError(404)

        uid = self.uid
        user = yield self.get_user(uid)
        if aid in user['activities']:
            if user['activities'][aid] == 0:
                res = yield self.sql.runQuery("SELECT gold, rock, feat, hp, prods, nums, created_at, ended_at FROM core_activity WHERE aid=%s LIMIT 1", (aid, ))
                gold, rock, feat, hp, prods, nums, created_at, ended_at = res[0]
                created_at = int(time.mktime(created_at.timetuple()))
                ended_at = int(time.mktime(ended_at.timetuple()))
                now = int(time.mktime(datetime.datetime.now().timetuple()))
                if now < created_at or now > ended_at:
                    self.write(dict(err=E.ERR_ACTIVITY_END, msg=E.errmsg(E.ERR_ACTIVITY_END)))
                    return
                prods = dict(zip(prods.split(','), [int(n) for n in nums.split(',')]))
                user['gold'] += gold
                user['rock'] += rock
                user['feat'] += feat
                hp, tick = yield self.add_hp(user, hp)
                for prod, n in prods.items():
                    if prod in user['prods']:
                        user['prods'][prod] += n
                    else:
                        user['prods'][prod] = n
                    if user['prods'][prod] > 999:
                        user['prods'][prod] = 999
                    elif user['prods'][prod] == 0:
                        del user['prods'][prod]
                    else:pass
                user['activities'][aid] = 1
                cuser = dict(gold=user['gold'], rock=user['rock'], hp=hp, feat=user['feat'], prods=user['prods'], activities=user['activities'])
                nuser = dict(gold=user['gold'], rock=user['rock'], feat=user['feat'], prods=user['prods'], activities=user['activities'])
                yield self.set_user(uid, **nuser)
                ret = dict(out=dict(user=cuser), timestamp=int(time.time()))
                reb = zlib.compress(escape.json_encode(ret))
                self.write(ret)
            elif user['activities'][aid] == -1:
                self.write(dict(err=E.ERR_ACTIVITY_DISSATISFY, msg=E.errmsg(E.ERR_ACTIVITY_DISSATISFY)))
                return
            elif user['activities'][aid] == 1:
                self.write(dict(err=E.ERR_ACTIVITY_ALREADYGOT, msg=E.errmsg(E.ERR_ACTIVITY_ALREADYGOT)))
                return
            else:pass
        else:
            self.write(dict(err=E.ERR_ACTIVITY_NOTFOUND, msg=E.errmsg(E.ERR_ACTIVITY_NOTFOUND)))
            return         

